/* ------------------------------------------------------------------------- **
 *
 * ------------------------------------------------------------------------- **
 *
 *  Simple, but incorrect grammar
 *  EQL -> EQ; EQL | empty
 *  EQ -> E = E
 *  E -> number | E + E | E - E
 *
 * ------------------------------------------------------------------------- */

%language "c++"

%skeleton "lalr1.cc"
%defines
%define api.value.type variant
%param {yy::LexerDriver* driver}

%code requires
{
#include <iostream>
#include <string>
#include <utility>

// forward decl of argument to parser
namespace yy { class LexerDriver; }
}

%code
{
#include "lexerdriver.hpp"

namespace yy {

parser::token_type yylex(parser::semantic_type* yylval,                         
                         LexerDriver* driver);
}
}

%token
  DEBUG_TOKEN "alex_great"
  EQUAL
  MINUS
  PLUS
  COLON
  SCOLON
  COMMA
  ERR
  
  EQ
  NOTEQ
  GE
  LE
  G
  L
  
  LINE_COMMENT
  
  CHAR
  INT
  FLOAT
  DOUBLE
  EXTERN_INPUT

  CURVED_BRACKET_LEFT
  CURVED_BRACKET_RIGHT
  SQUARE_BRACKET_LEFT
  SQUARE_BRACKET_RIGHT
  ROUND_BRACKET_LEFT
  ROUND_BRACKET_RIGHT
;

%token <int> NUMBER
%token <const char*> VARNAME
%nterm <int> var_decl
%nterm var_type
%nterm input

%left '+' '-'

%start program

%%

program : statements
;

/* scope & statements */
func_body : CURVED_BRACKET_LEFT statements CURVED_BRACKET_RIGHT
scope : CURVED_BRACKET_LEFT statements CURVED_BRACKET_RIGHT statements
;

statements : %empty
           | statement statements
           | scope
;

statement : DEBUG_TOKEN SCOLON
          | var_decl SCOLON
          | func_decl SCOLON
;

/*
1.2. Types

Every entity introduced by its first mention. Entity have associated type that is either specified or deduced.
Special input and output are generic IO entities.
You may imagine input(0) as a typed stdin and output(0) as a typed stdout.
Definite meaning of those are given at layer 3.

v0 = 0;
v1 : double = v0;
v2 = input(0) : int; // not input(v0)
v3 : int;
output(0, v1);

For int type you may directly specify size.

v0 : int(16) = 0; // 16-bit int

Default int is 32.

Integer are two's complement signed numbers with two's complement signed wrap. No UB here.
*/

// var declarations
var_decl : VARNAME COLON var_type EQUAL input
         | VARNAME COLON var_type { std::cout << strdup($1) << std::endl; }
         | VARNAME EQUAL input
;

basic_type :  CHAR
           |  INT
           |  FLOAT
           |  DOUBLE
;

var_type:  basic_type
        |  INT ROUND_BRACKET_LEFT NUMBER ROUND_BRACKET_RIGHT
;

input: NUMBER
     | extern_input
;

extern_input : EXTERN_INPUT ROUND_BRACKET_LEFT NUMBER ROUND_BRACKET_RIGHT COLON basic_type
             | EXTERN_INPUT ROUND_BRACKET_LEFT NUMBER ROUND_BRACKET_RIGHT
;

/*
1.5. Functions

Function entity is an abstraction mechanism. It is a callable.

f0 = { v3 = input(0) + 1; v3 * v3; };
v7 = f0(2); // but not f0(2, 3)
f1 : (x) = { v3 = x + 1; v3 * v3; };
f2 : (x, y) = { v3 = x + y; v3 * v3; };
f3 : (x : int, y : double) : int = { v3 = x + y; v3 * v3; };
v8 = f3(v0, v1);

Normal function return is an entity generated by the last expression.
*/

// function declarations
func_decl : VARNAME func_args_decl EQUAL func_body
          | VARNAME EQUAL func_body
;

func_args_decl : COLON ROUND_BRACKET_LEFT func_args_decl_list ROUND_BRACKET_RIGHT COLON basic_type
               | COLON ROUND_BRACKET_LEFT func_args_decl_list ROUND_BRACKET_RIGHT
;

func_args_decl_list : func_arg_decl
                    | func_arg_decl COMMA func_args_decl_list
;

func_arg_decl : VARNAME COLON basic_type
              | VARNAME
;

%%

namespace yy {

parser::token_type yylex(parser::semantic_type* yylval,                         
                         LexerDriver* driver)
{
  return driver->yylex(yylval);
}

void parser::error(const std::string& msg){
  std::cerr << "Bison parser error:    " << msg << "\n";
}
}