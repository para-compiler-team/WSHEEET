/* ------------------------------------------------------------------------- **
 *
 * ------------------------------------------------------------------------- **
 *
 *  Simple, but incorrect grammar
 *  EQL -> EQ; EQL | empty
 *  EQ -> E = E
 *  E -> number | E + E | E - E
 *
 * ------------------------------------------------------------------------- */

%language "c++"

%skeleton "lalr1.cc"
%defines
%define api.value.type variant
%param {yy::LexerDriver* driver}

%code requires
{
#include <iostream>
#include <string>
#include <utility>

// forward decl of argument to parser
namespace yy { class LexerDriver; }
}

%code
{
#include "lexerdriver.hpp"

namespace yy {

parser::token_type yylex(parser::semantic_type* yylval,                         
                         LexerDriver* driver);
}
}

%token
  DEBUG_TOKEN "alex_great"
  EQUAL
  MINUS
  PLUS
  MUL
  DIV
  AND
  OR
  COLON
  SCOLON
  COMMA
  RANGE
  ERR

  IF
  ELSE
  WHILE
  FOR

  FLOAT_NUMBER
  
  EQ
  NOTEQ
  GE
  LE
  G_BRACKET
  L_BRACKET
  
  LINE_COMMENT
  
  INT
  FLOAT
  DOUBLE
  EXTERN_INPUT
  REPEAT
  VECTOR

  CURVED_BRACKET_LEFT
  CURVED_BRACKET_RIGHT
  SQUARE_BRACKET_LEFT
  SQUARE_BRACKET_RIGHT
  ROUND_BRACKET_LEFT
  ROUND_BRACKET_RIGHT
;

%token <int> INT_NUMBER
%token <const char*> VARNAME
%token <char> CHAR
%nterm <int> var_decl
%nterm var_type
%nterm input

%left PLUS MINUS
%left MUL DIV
%left NEG

%start program

%%

program : statements
;

/* scope & statements */
func_body : CURVED_BRACKET_LEFT statements CURVED_BRACKET_RIGHT
;
scope : CURVED_BRACKET_LEFT statements CURVED_BRACKET_RIGHT statements
;
single_scope : CURVED_BRACKET_LEFT statements CURVED_BRACKET_RIGHT
             | statement
;

statements : %empty
           | statement statements
           | scope
;

statement : DEBUG_TOKEN SCOLON
          | var_decl SCOLON
          | func_decl SCOLON
          | array_decl SCOLON
          | if_statement
          | else_statement
          | while_statement
          | right_expression SCOLON
;

// basic types & elements
basic_type :  CHAR
           |  INT
           |  FLOAT
           |  DOUBLE
;

element : basic_element
        | VARNAME
;

basic_element : INT_NUMBER
              | FLOAT_NUMBER
              | CHAR
;

// expressions
right_expression: arithmetic_expression
;

/*
arithmetic_operator: MUL
                   | DIV
                   | PLUS
                   | MINUS
;

arithmetic_scope: ROUND_BRACKET_LEFT arithmetic_expression ROUND_BRACKET_RIGHT
;

arithmetic_expression: element
                     | arithmetic_expression arithmetic_operator element
                     | arithmetic_scope
;
*/

arithmetic_expression: element
| arithmetic_expression PLUS arithmetic_expression
| arithmetic_expression MINUS arithmetic_expression
| arithmetic_expression MUL arithmetic_expression
| arithmetic_expression DIV arithmetic_expression
| MINUS arithmetic_expression %prec NEG
| ROUND_BRACKET_LEFT arithmetic_expression ROUND_BRACKET_RIGHT
;

/*
1.2. Types

Every entity introduced by its first mention. Entity have associated type that is either specified or deduced.
Special input and output are generic IO entities.
You may imagine input(0) as a typed stdin and output(0) as a typed stdout.
Definite meaning of those are given at layer 3.

v0 = 0;
v1 : double = v0;
v2 = input(0) : int; // not input(v0)
v3 : int;
output(0, v1);

For int type you may directly specify size.

v0 : int(16) = 0; // 16-bit int

Default int is 32.

Integer are two's complement signed numbers with two's complement signed wrap. No UB here.
*/

// var declarations
var_decl : VARNAME COLON var_type EQUAL input
         | VARNAME COLON var_type
         | VARNAME EQUAL input
;

var_type:  basic_type
        |  INT ROUND_BRACKET_LEFT INT_NUMBER ROUND_BRACKET_RIGHT
;

input: INT_NUMBER
     | extern_input
;

extern_input : EXTERN_INPUT ROUND_BRACKET_LEFT INT_NUMBER ROUND_BRACKET_RIGHT COLON basic_type
             | EXTERN_INPUT ROUND_BRACKET_LEFT INT_NUMBER ROUND_BRACKET_RIGHT
;

/*
1.5. Functions

Function entity is an abstraction mechanism. It is a callable.

f0 = { v3 = input(0) + 1; v3 * v3; };
v7 = f0(2); // but not f0(2, 3)
f1 : (x) = { v3 = x + 1; v3 * v3; };
f2 : (x, y) = { v3 = x + y; v3 * v3; };
f3 : (x : int, y : double) : int = { v3 = x + y; v3 * v3; };
v8 = f3(v0, v1);

Normal function return is an entity generated by the last expression.
*/

// function declarations
func_decl : VARNAME func_args_decl EQUAL func_body
          | VARNAME EQUAL func_body
;

func_args_decl : COLON ROUND_BRACKET_LEFT func_args_decl_list ROUND_BRACKET_RIGHT COLON basic_type
               | COLON ROUND_BRACKET_LEFT func_args_decl_list ROUND_BRACKET_RIGHT
;

func_args_decl_list : func_arg_decl
                    | func_arg_decl COMMA func_args_decl_list
;

func_arg_decl : VARNAME COLON basic_type
              | VARNAME
;

/*
1.3. Arrays

Array entity is syntactic glue for the couple of entities of the same type. Array have CT-known size.
Special arryas are vectors. Vectors have both CT-known size and CT-known indexes.

arr0 = repeat(v0, 5); // array of 5
arr1 : int[5] = {1, 2, 3, 4}; // array of 5
arr2 : vector<int, 5> = {1, 2, 3, 4, 5}; // vector
v3 = 3;
v4 = arr0[v3];
v5 = arr2[3]; // not arr2[v3]
arr_inputs = input(0..3) : int[4]; // array of 4
*/

// array declarations
array_decl: VARNAME COLON array_type EQUAL array_body
          | VARNAME EQUAL array_body
;

array_type: array_basic_type
          | array_vector_type
;

array_basic_type : basic_type SQUARE_BRACKET_LEFT INT_NUMBER SQUARE_BRACKET_RIGHT 
;

array_vector_type : VECTOR L_BRACKET basic_type COMMA INT_NUMBER G_BRACKET
;

array_body : CURVED_BRACKET_LEFT array_list CURVED_BRACKET_RIGHT
           | REPEAT ROUND_BRACKET_LEFT VARNAME COMMA INT_NUMBER ROUND_BRACKET_RIGHT
           | EXTERN_INPUT ROUND_BRACKET_LEFT INT_NUMBER RANGE INT_NUMBER ROUND_BRACKET_RIGHT COLON array_basic_type 
;

array_list : basic_element COMMA array_list
           | basic_element
;

// conditions

if_statement: IF ROUND_BRACKET_LEFT conditions ROUND_BRACKET_RIGHT condition_body
;


else_statement: ELSE condition_body
;

while_statement : WHILE ROUND_BRACKET_LEFT conditions ROUND_BRACKET_RIGHT condition_body

conditions : element 
           | element condition_operator conditions
           | conditional_scope
;

condition_operator: L_BRACKET
                    | G_BRACKET
                    | GE
                    | LE
                    | AND
                    | OR
                    | EQ
                    | NOTEQ
;

conditional_scope : ROUND_BRACKET_LEFT conditions ROUND_BRACKET_RIGHT
;

condition_body: single_scope
;

%%

namespace yy {

parser::token_type yylex(parser::semantic_type* yylval,                         
                         LexerDriver* driver)
{
  return driver->yylex(yylval);
}

void parser::error(const std::string& msg){
  std::cerr << "Bison parser error:    " << msg << "\n";
}
}